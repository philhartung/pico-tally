<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OBS Monitoring</title>

	<style type="text/css">
        :root {
            --address: 'ws://127.0.0.1:4455'; /* OBS Websocket address */
            --password: 'password'; /* OBS Websocket password */
        }
    </style>
</head>
<body>
	<div>

    </div>

	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/obs-websocket-js"></script>
	<script type="text/javascript">
		const obs = new OBSWebSocket();
        const config = {
            lights: [
                {
                    host: '192.168.1.107:7413',
                    target: 'source', // scene oder source
                    name: 'SRC SDI1'
                },
                {
                    host: '192.168.1.212:7413',
                    target: 'source',
                    name: 'SRC SDI2'
                },
                {
                    host: '192.168.1.108:7413',
                    target: 'source',
                    name: 'SRC SDI3'
                },
            ]
        };
        
        // global vars
        let updateTimeout;
        let deepMappingTimeout;
        let updateTimeoutMS = 50;
        let status = {
            preview: '',
            program: ''
        };
        let mapping = {};
        
        const updateLight = function(update){
          const request = new XMLHttpRequest();
          request.timeout = 2000;

          request.onload = () => console.log(`Updated ${update.host}`);
          request.onerror = () => console.log(`Error updating ${update.host}`);
          request.ontimeout = () => console.log(`Timeout updating ${update.host}`);

          request.open('GET', `http://${update.host}/setRGB?r=${update.r}&g=${update.g}&b=${update.b}&brightness=${update.brightness}`, true);
          request.send();
        };

        const updateLights = function(){
            // iterate over all lights and calc update
            updateTimeout = null;
            update = [];

            for(let i = 0; i < config.lights.length; i++){
                let light = config.lights[i];

                if(light.target == 'scene'){
                    if(light.name == status.program){
                        update.push({host: light.host, r: 255, g: 0, b: 0, brightness: 0.1});
                    }else if(light.name == status.preview){
                        update.push({host: light.host, r: 0, g: 255, b: 0, brightness: 0.1});
                    }else{
                        update.push({host: light.host, r: 0, g: 0, b: 0, brightness: 0});
                    }
                }else if(light.target == 'source'){
                    if(mapping[status.program].sources.includes(light.name)){
                        update.push({host: light.host, r: 255, g: 0, b: 0, brightness: 0.1});
                    }else if(mapping[status.preview].sources.includes(light.name)){
                        update.push({host: light.host, r: 0, g: 255, b: 0, brightness: 0.1});
                    }else{
                        update.push({host: light.host, r: 0, g: 0, b: 0, brightness: 0});
                    }
                }
            }

            // execute Update
            for(let i = 0; i < update.length; i++){
                updateLight(update[i]);
            }
        }

        let init = function(){
            // fetch current status
            console.log('Getting current status')
            obs.call('GetCurrentProgramScene').then(function(data){
                status.program = data.currentProgramSceneName;

                if(updateTimeout){
                    clearTimeout(updateTimeout);
                }

                updateTimeout = setTimeout(updateLights, updateTimeoutMS);
			});

			obs.call('GetCurrentPreviewScene').then(function(data){
                status.preview = data.currentPreviewSceneName;
                                
                if(updateTimeout){
                    clearTimeout(updateTimeout);
                }

                updateTimeout = setTimeout(updateLights, updateTimeoutMS);
			});

            updateMapping();
        }

        let updateMapping = function(){
            obs.call('GetSceneList', {sceneName: 'Nested'}).then(function(data){
				for(let i = 0; i < data.scenes.length; i++){
                    let sceneName = data.scenes[i].sceneName;
                    iterateItems(sceneName);
                }
			});
        }

        let iterateItems = function(name){
            obs.call('GetSceneItemList', {sceneName: name}).then(function(data){
                for(let j = 0; j < data.sceneItems.length; j++){
                    console.log(name, data.sceneItems[j].sourceName, data.sceneItems[j].sourceType);
                    if(!mapping[name]){
                        mapping[name] = {
                            sources: [],
                            scenes: [],
                        }
                    }

                    if(data.sceneItems[j].sourceType == 'OBS_SOURCE_TYPE_SCENE'){
                        mapping[name].scenes.push(data.sceneItems[j].sourceName);
                    }else if(data.sceneItems[j].sourceType == 'OBS_SOURCE_TYPE_INPUT'){
                        mapping[name].sources.push(data.sceneItems[j].sourceName);
                    }
                }

                if(deepMappingTimeout){
                    clearTimeout(deepMappingTimeout);
                }

                deepMappingTimeout = setTimeout(updateDeepMapping, 10);
            });
        };

        let updateDeepMapping = function(){
            deepMappingTimeout = null;

            for (let key in mapping) {
                if (mapping.hasOwnProperty(key)) {
                    const value = mapping[key];
                    console.log(`Key: ${key}, Value: `, value);
                    for(let i = 0; i < value.scenes.length; i++){
                        updateDeepMappingRec(key, value.scenes[i], 0);
                    }
                }
            }
        }

        let updateDeepMappingRec = function(scene, recursive, deep){
            console.log(scene, recursive, deep)
            obs.call('GetSceneItemList', {sceneName: recursive}).then(function(data){
                for(let j = 0; j < data.sceneItems.length; j++){
                    if(data.sceneItems[j].sourceType == 'OBS_SOURCE_TYPE_SCENE' && deep < 10){
                        updateDeepMappingRec(scene, data.sceneItems[j].sourceName, deep++);
                    }else if(data.sceneItems[j].sourceType == 'OBS_SOURCE_TYPE_INPUT'){
                        mapping[scene].sources.push(data.sceneItems[j].sourceName);
                    }
                }
            });
        }

		let initInterval = setInterval(function(){
			let wsAddress = getComputedStyle(document.documentElement).getPropertyValue('--address').trim();
			wsAddress = wsAddress.substring(1, wsAddress.length - 1);
			
			let wsPasswd = getComputedStyle(document.documentElement).getPropertyValue('--password').trim();
			wsPasswd = wsPasswd.substring(1, wsPasswd.length - 1);

			if(wsAddress != '' && wsPasswd != ''){
                console.log('Connecting to', wsAddress);
				obs.connect(wsAddress, wsPasswd, {eventSubscriptions: OBSWebSocket.EventSubscription.Scenes + OBSWebSocket.EventSubscription.General});
				clearInterval(initInterval);
			}
		}, 250);

		obs.on('ConnectionOpened', function(){
			console.log('Connected');
            setTimeout(init, 100);
		});

        obs.on('CurrentProgramSceneChanged', function(event){
            status.program = event.sceneName;

            if(updateTimeout){
                clearTimeout(updateTimeout);
            }

            updateTimeout = setTimeout(updateLights, updateTimeoutMS);
        });

        obs.on('CurrentPreviewSceneChanged', function(event){
			status.preview = event.sceneName;

            if(updateTimeout){
                clearTimeout(updateTimeout);
            }

            updateTimeout = setTimeout(updateLights, updateTimeoutMS);
        });

        obs.on('ExitStarted', function(){
            console.log('exit');
            status.program = '';
            status.preview = '';
            updateLights();
        });       
	</script>
</body>
</html>